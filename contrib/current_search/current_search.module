<?php

/**
 * @file
 * Provides an interface for creating blocks containing information about the
 * current search.
 */

/**
 * Display current search block only when keywords are entered.
 */
define('CURRENT_SEARCH_DISPLAY_KEYS', 0);

/**
 * Display current search block on empty searches where no keywords are entered.
 */
define('CURRENT_SEARCH_DISPLAY_ALWAYS', 1);

/**
 * Display current search block only when one or more facet items are active.
 */
define('CURRENT_SEARCH_DISPLAY_FILTERS', 2);

/**
 * Display current search block when either keywords are entered one or more
 * facet items are active.
 */
define('CURRENT_SEARCH_DISPLAY_KEYS_FILTERS', 3);

// Includes the Block hooks and form alterations.
require_once dirname(__FILE__) . '/current_search.block.inc';

/**
 * Implements hook_menu_alter().
 */
function current_search_menu() {
  $items = array();

  $items['admin/config/search/current_search/item/%current_search_item/delete/%'] = array(
    'title' => 'Revert current search block configuration',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('current_search_delete_item_form', 5, 7),
    'access arguments' => array('administer search'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'plugins/export_ui/current_search_export_ui.class.php',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function current_search_menu_alter(&$items) {
  // Use same access callback as Facet API. We can't define access callbacks in
  // CTools plugins, so we have to alter the menu and define them here.
  $base_path = 'admin/config/search/current_search';
  foreach ($items as $path => $item) {
    if ($base_path == $path || 0 === strpos($path, "$base_path/")) {
      $items[$path]['access callback'] = 'facetapi_access_callback';
      $items[$path]['access arguments'] = array();
    }
  }

  // Ensures that the edit link shows up in contextual links.
  $item = &$items['admin/config/search/current_search/list/%ctools_export_ui/edit'];
  $item['title'] = 'Configure current search items';
  $item['type'] = MENU_LOCAL_ACTION;
  $item['context'] = MENU_CONTEXT_INLINE;
}

/**
 * Implements hook_theme().
 */
function current_search_theme() {
  return array(
    'current_search_group_title' => array(
      'arguments' => array('title' => NULL),
      'file' => 'current_search.theme.inc',
    ),
    'current_search_text' => array(
      'arguments' => array('text' => NULL, 'wrapper' => NULL, 'element' => NULL, 'css' => NULL, 'class' => array()),
      'file' => 'current_search.theme.inc',
    ),
    'current_search_link_active' => array(
      'arguments' => array('text' => NULL, 'path' => NULL, 'options' => array()),
      'file' => 'current_search.theme.inc',
    ),
    'current_search_keys' => array(
      'arguments' => array('keys' => NULL, 'adapter' => NULL),
      'file' => 'current_search.theme.inc',
    ),
    'current_search_deactivate_widget' => array(
      'file' => 'current_search.theme.inc',
    ),
    'current_search_item_wrapper' => array(
      'render element' => 'element',
      'file' => 'current_search.theme.inc',
    ),
    'current_search_group_wrapper' => array(
      'render element' => 'element',
      'file' => 'current_search.theme.inc',
    ),
    'current_search_sort_settings_table' => array(
      'render element' => 'element',
      'file' => 'current_search.theme.inc',
    ),
    'current_search_accessible_markup' => array(
      'arguments' => array('text' => NULL, 'active' => FALSE),
      'file' => 'current_search.theme.inc',
    ),
  );
}

/**
 * Returns an array of available current search plugins.
 *
 * @return array
 *   An associative array keyed by plugin ID to human readable label.
 */
function current_search_get_plugins() {
  $plugins = &backdrop_static(__FUNCTION__, array());
  if (!$plugins) {
    foreach (facetapi_get_plugins('current_search', 'items') as $id => $plugin) {
      $plugins[$id] = $plugin['handler']['label'];
    }
  }
  return $plugins;
}

/**
 * Returns an array of searcher options.
 *
 * @return
 *   An array of options.
 */
function current_search_get_searcher_options() {
  $options = array();
  foreach (facetapi_get_searcher_info() as $name => $info) {
    $options[$name] = $info['label'];
  }
  return $options;
}

/**
 * Returns the settings for a current search block configuration.
 *
 * @param $name
 *   The machine readable name of the configuration.
 *
 * @return stdClass
 *   An object containing the configuration, FALSE if not defined.
 */
function current_search_item_load($name) {
  // cttools_include('export');
  $result = ctools_export_crud_load('current_search', $name);
  return $result ? $result : FALSE;
}

/**
 * Implements hook_current_search_items().
 */
function current_search_current_search_items() {
  return array(
    'text' => array(
      'handler' => array(
        'label' => t('Custom text'),
        'class' => 'CurrentSearchItemText',
      ),
    ),
    'active' => array(
      'handler' => array(
        'label' => t('Active items'),
        'class' => 'CurrentSearchItemActive',
      ),
    ),
    'group' => array(
      'handler' => array(
        'label' => t('Field group'),
        'class' => 'CurrentSearchGroup',
      ),
    ),
  );
}

/*
 *
 */
function current_search_export_crud_load_all($table, $reset = FALSE) {
  $schema = current_search_export_get_schema($table);
  if (empty($schema['export'])) {
    return array();
  }
  $export = $schema['export'];
  if (!empty($export['load all callback']) && function_exists($export['load all callback'])) {
    return $export['load all callback']($reset);
  }
  else {
    return current_search_export_load_object($table);
  }
}

/*
 *
 */
function current_search_export_get_schema($table) {
  $cache = &backdrop_static(__FUNCTION__);
   if (empty($cache[$table])) {
     $schema = backdrop_get_schema($table);
     // If our schema isn't loaded, it's possible we're in a state where it
     // simply hasn't been cached. If we've been asked, let's force the
     // issue.
     if (!$schema || empty($schema['export'])) {
       // force a schema reset:
       $schema = backdrop_get_schema($table, TRUE);
     }
     if (!isset($schema['export'])) {
       return array();
     }
     if (empty($schema['module'])) {
       return array();
     }
     // Add some defaults
     $schema['export'] += array(
       'key' => 'name',
       'key name' => 'Name',
       'object' => 'stdClass',
       'status' => 'default_' . $table,
       'default hook' => 'default_' . $table,
       'can disable' => TRUE,
       'identifier' => $table,
       'primary key' => !empty($schema['primary key']) ? $schema['primary key'][0] : '',
       'bulk export' => TRUE,
       'list callback' => "$schema[module]_{$table}_list",
       'to hook code callback' => "$schema[module]_{$table}_to_hook_code",
       'cache defaults' => FALSE,
       'default cache bin' => 'cache',
       'export type string' => 'type',
     );
     // If the export definition doesn't have the "primary key" then the CRUD
     // save callback won't work.
     if (empty($schema['export']['primary key']) && user_access('administer site configuration')) {
       backdrop_set_message(t('The export definition of @table is missing the "primary key" property.', array('@table' => $table)), 'error');
     }
     $cache[$table] = $schema;
   }
   return $cache[$table];
 }

 /*
  *
  */
  // TODO $type is always == 'all' so lets remove the cruft if we can
 function current_search_export_load_object($table, $args = array()) {
   $cache = &backdrop_static(__FUNCTION__);
   $cached_database = &backdrop_static('ctools_export_load_object_all');
   $schema = current_search_export_get_schema($table);
   if (empty($schema)) {
     return array();
   }
   $export = $schema['export'];
   if (!isset($cache[$table])) {
     $cache[$table] = array();
   }
   // If fetching all and cached all, we've done so and we are finished.
   if ( !empty($cached_database[$table]) ) {
     return $cache[$table];
   }
   // Build the query
   $query = db_select($table, 't__0')->fields('t__0');
   $alias_count = 1;
   if (!empty($schema['join'])) {
     foreach ($schema['join'] as $join_key => $join) {
       if ($join_schema = backdrop_get_schema($join['table'])) {
         $query->join($join['table'], 't__' . $alias_count, 't__0.' . $join['left_key'] . ' = ' . 't__' . $alias_count . '.' . $join['right_key']);
         $query->fields('t__' . $alias_count);
         $alias_count++;
         // Allow joining tables to alter the query through a callback.
         if (isset($join['callback']) && function_exists($join['callback'])) {
           $join['callback']($query, $schema, $join_schema);
         }
       }
     }
   }
   $result = $query->execute();

   $status = variable_get($export['status'], array()); // TODO create a config for this
   // Unpack the results of the query onto objects and cache them.
   foreach ($result as $data) {
     if (isset($schema['export']['object factory']) && function_exists($schema['export']['object factory'])) {
       $object = $schema['export']['object factory']($schema, $data);
     }
     else {
       $object = current_search_export_unpack_object($schema, $data, $export['object']);
     }
     $object->table = $table;
     $object->{$export['export type string']} = t('Normal');
     $object->export_type = EXPORT_IN_DATABASE;
     // Determine if default object is enabled or disabled.
     if (isset($status[$object->{$export['key']}])) {
       $object->disabled = $status[$object->{$export['key']}];
     }
     $cache[$table][$object->{$export['key']}] = $object;
   }
   // Load subrecords.
   if (isset($export['subrecords callback']) && function_exists($export['subrecords callback'])) {
     $export['subrecords callback']($cache[$table]);
   }
     $cached_database[$table] = TRUE;
     return $cache[$table];
 }

 /*
  *
  */
 function current_search_export_unpack_object($schema, $data, $object = 'stdClass') {
   if (is_string($object)) {
     if (class_exists($object)) {
       $object = new $object;
     }
     else {
       $object = new stdClass;
     }
   }
   // Go through our schema and build correlations.
   foreach ($schema['fields'] as $field => $info) {
     if (isset($data->$field)) {
       $object->$field = empty($info['serialize']) ? $data->$field : unserialize($data->$field);
     }
     else {
       $object->$field = NULL;
     }
   }
   if (isset($schema['join'])) {
     foreach ($schema['join'] as $join_key => $join) {
       $join_schema = current_search_export_get_schema($join['table']);
       if (!empty($join['load'])) {
         foreach ($join['load'] as $field) {
           $info = $join_schema['fields'][$field];
           $object->$field = empty($info['serialize']) ? $data->$field : unserialize(db_decode_blob($data->$field));
         }
       }
     }
   }
   return $object;
 }

/**
 * Implements hook_autoload_info().
 */
function current_search_autoload_info() {
  return array(
    'CurrentSearchItem' => 'plugins/current_search/item.inc',
    'CurrentSearchItemActive' => 'plugins/current_search/item_active.inc',
    'CurrentSearchGroup' => 'plugins/current_search/item_group.inc',
    'CurrentSearchItemText' => 'plugins/current_search/item_text.inc',
    'current_search_export_ui' => 'plugins/export_ui/current_search_export_ui.class.php',
  );
}
